[{"content":"Youtube: Channels:  CS Dojo: anthonywritescode: Florian Dahlitz: sentdex: Corey Schafer: Al Sweigart: Real Python:  ","permalink":"https://abotyim.github.io/en/posts/resources/python/","summary":"Python is a programming language that lets you work quickly and integrate systems more effectively.","title":"Python Programming Language"},{"content":"Youtube: Channels:  Very Academy: The Dumbfounds: CodingEntrepreneurs: Dennis Ivy: JustDjango: Legion Script: Codemy.com: Code Artisan Lab: Code Environment: Pyplane: Aarav Tech: Vitor Freitas: Max Goodridge: Corey Schafer: Pretty Printed: Django Lessons:  Playlist: Forms:  Django Forms. Build a Dynamic Filter Form.  Selenium:  Selenium Mastery with Django.  Testing:  Pytest Mastery with Django. Learn Django - Testing Series. Django Testing Tutorial - How To Test Your Django Applications (Using The Unittest Module). Django Pytest Tutorial.  API:  Learn Django Rest Framework. Next.js | DRF - Ecommerce Project. Django Project - Quiz API. Django Project - Image API Service. Learn Django API. Create A REST API with Django. Django REST Framework Tutorials. Build an API with Django. Teach Me Django. Local Reviews Site With NextJS and Django Rest Framework. Todo App Django Rest Framework + React. Build An API With Python and Django. Django REST API. Django Rest Framework. Django, Django Rest Framework and React js tutorial series. Django Rest Framework Tutorials. Introduction to Django Rest Framework. Authentication with Django \u0026amp; React. Next.js | GraphQL | Django - Ecommerce Project. GraphQL.  Models \u0026amp; ORM:  Django ORM Mastery Series. Learn Django - Models.  Translate:  Django Internationalization.  Admin:  Learn Django - Admin.  Packages:  Learn Django - Package Reviews. Django Package Review.  Projects:  Try Django 3.2 - Python Web Development Tutorial Series. Django - Ecommerce Project. Django - Ecommerce Project v2. Learn Django - Project Chatrooms. Django Project - Build a Simple Blog. Django 2 Tutorial: Build A Budget Application. Django Bootcamp - October 2020. Django Code Review. Python Django 2021 Course Sessions. Django Ecommerce Website. Django Projects. Django (3.0) Crash Course Tutorials | Customer Management App. Build an Ecommerce Website with Django and React. Build an Ecommerce Website with Django. Django and React. Video Sharing Web App Python 3 \u0026amp; Django. Food Delivery Web App With Python 3 and Django. Social Media Web App With Python 3 and Django. Create A Simple Django Blog. Air Quality Weather App With Python and Django. GYM Management System in Django and PostgreSQL. Ecommerce Website in Django. Django ReactJs. Employee Register App. Django News Website. Quiz App in Django and Javascript. Django with Javascript. Django Social Network Project v2.0 with JS. Django \u0026amp; Beautiful Soup - Building an Amazon price tracker. Django with React js. Django with Data Science \u0026amp; OpenCV. Django realtime crypto app. Social Network in Django. django geolocation. Django Full Project.  Channel:  Build a chat application. Django Chat App With Django Channels. Django Channels 3. Django Channels 2.  Deploy:  Learn Django - Deploy. Heroku Deployment. Deploy Django - From Zero to Hero. Django Deployments.  Other:  Learn Django - Theory. Learn Django - Class-Based Views. Learn Django - Celery. Docker Mastery with Django. Learn Django. Django Security - Build More Secure Web Applications. Django Fundamentals For Beginners - Get Started Quickly!. Django Design Patterns - Make Your Applications Cleaner And Maintainable. Real Django Website. Django How To\u0026hellip;. Custom Django. Django Wednesdays. Django 3. Django Tutorials. Question Answer Website in Django. Practical Django. Beyond the basics of Django. Django and Stripe payments. Celery with Django. Django 2 Tutorials. Django. Payments. Celery. Django Applications. Live Streams \u0026amp; Guests.  Crash Courses:  Authentication \u0026amp; Refreshing Tokens Implementation. Abstract User, User Profile and Signals in Django (how to add extra fields to the user model).  ","permalink":"https://abotyim.github.io/en/posts/resources/django/","summary":"Django makes it easier to build better web apps more quickly and with less code.","title":"Django Web Framework"},{"content":"Methods That Return QuerySets:    Method Description     filter() Filter by the given lookup parameters. Multiple parameters are joined by SQL AND statements   exclude() Filter by objects that don’t match the given lookup parameters   order_by() Change the default ordering of the QuerySet   reverse() Reverse the default ordering of the QuerySet   distinct() Perform an SQL SELECT DISTINCT query to eliminate duplicate rows   values() Returns dictionaries instead of model instances   values_list() Returns tuples instead of model instances   dates() Returns a QuerySet containing all available dates in the specified date range   datetimes() Returns a QuerySet containing all available dates in the specified date and time range   none() Create an empty QuerySet   all() Return a copy of the current QuerySet   union() Use the SQL UNION operator to combine two or more QuerySets   intersection() Use the SQL INTERSECT operator to return the shared elements of two or more QuerySets   difference() Use the SQL EXCEPT operator to return elements in the first QuerySet that are not in the others   select_related() Select all related data when executing the query (except many-to-many relationships)   prefetch_related() Select all related data when executing the query (including many-to-many relationships)   defer() Do not retrieve the names fields from the database. Used to improve query performance on complex datasets   only() Opposite of **defer() : **return only the name fields   using() Select which database the QuerySet will be evaluated against (when using multiple databases)   select_for_update() Return a QuerySet that will lock rows until the end of the transaction   raw() Execute a raw SQL statement   AND (\u0026amp;) Combine two QuerySets with the SQL AND operator. Using AND (\u0026amp;) is functionally equivalent to using filter() with multiple parameters   OR (|) Combine two QuerySets with the SQL OR operator   annotate() Annotate each object in the QuerySet. Annotations can be simple values, a field reference or an aggregate expression    Let’s go ahead and use the Django interactive shell to explore a few examples of the more common QuerySet methods.\nfilter() queryset = User.objects.filter(first_name=\u0026#39;Ahmed\u0026#39;) queryset \u0026lt;QuerySet [\u0026lt;User: Ahmed\u0026gt;, \u0026lt;User: Ahmed\u0026gt;, \u0026lt;User: Ahmed\u0026gt;]\u0026gt; exclude() return a QuerySet of objects that don’t match the given lookup parameters, for example:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Venue \u0026gt;\u0026gt;\u0026gt; Venue.objects.exclude(name=\u0026#34;South Stadium\u0026#34;) \u0026lt;QuerySet [\u0026lt;Venue: West Park\u0026gt;, \u0026lt;Venue: North Stadium\u0026gt;, \u0026lt;Venue: East Park\u0026gt;]\u0026gt; Using more than one lookup parameter will use an SQL AND operator under the hood:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; venue1 = Venue.objects.get(name=\u0026#34;East Park\u0026#34;) \u0026gt;\u0026gt;\u0026gt; Event.objects.exclude(venue=venue1,event_date=datetime.date(2019,10,8)) \u0026lt;QuerySet [\u0026lt;Event: Test Event\u0026gt;, \u0026lt;Event: Club Presentation - Juniors\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;]\u0026gt; order_by() and reverse() order_by() changes the default ordering of the QuerySet. Function parameters are the model fields to use to order the QuerySet. Ordering can be single level:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; Event.objects.all().order_by(\u0026#39;name\u0026#39;) \u0026lt;QuerySet [\u0026lt;Event: Club Presentation - Juniors\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;, \u0026lt;Event: Test Event\u0026gt;]\u0026gt; Or ordering can be multi-level. In the following example, the events are first ordered by event date and then by event name:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.all().order_by(\u0026#39;event_date\u0026#39;,\u0026#39;name\u0026#39;) \u0026lt;QuerySet [\u0026lt;Event: Club Presentation - Juniors\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;, \u0026lt;Event: Test Event\u0026gt;]\u0026gt; By default, QuerySet fields are ordered in ascending order. To sort in descending order, use the negative sign**(-)**:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.all().order_by(\u0026#39;-name\u0026#39;) \u0026lt;QuerySet [\u0026lt;Event: Test Event\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Club Presentation - Juniors\u0026gt;]\u0026gt; reverse() reverses the default ordering of the QuerySet:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.all().reverse() \u0026lt;QuerySet [\u0026lt;Event: Test Event\u0026gt;, \u0026lt;Event: Club Presentation - Juniors\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;]\u0026gt; Note:\n A model must have default ordering (by setting the ordering option of the models Meta class) for reverse() to be useful. If the model is unordered, the sort order of the returned QuerySet will be meaningless. Both order_by() and reverse() are not free operations—they come at a time cost to your database and should be used sparingly on large datasets.  values() and values_list() values() returns Python dictionaries, instead of a QuerySet object:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.values() \u0026lt;QuerySet [{\u0026#39;id\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;Test Event\u0026#39;, \u0026#39;event_date\u0026#39;: datetime.datetime(2019, 8, 25, 22, 42, 15, tzinfo=\u0026lt;UTC\u0026gt;), \u0026#39;venue_id\u0026#39;: 1, \u0026#39;manager_id\u0026#39;: 1, \u0026#39;description\u0026#39;: \u0026#34;It\u0026#39;s all happening here!\u0026#34;}, {\u0026#39;id\u0026#39;: 2, \u0026#39;name\u0026#39;: \u0026#39;Club Presentation - Juniors\u0026#39;, \u0026#39;event_date\u0026#39;: datetime.datetime(2019, 8, 1, 12, 0, tzinfo=\u0026lt;UTC\u0026gt;), \u0026#39;venue_id\u0026#39;: 4, \u0026#39;manager_id\u0026#39;: 2, \u0026#39;description\u0026#39;: \u0026#39;\u0026#39;}]\u0026gt; You can also specify which fields you want returned:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.values(\u0026#39;name\u0026#39;,\u0026#39;description\u0026#39;) \u0026lt;QuerySet [{\u0026#39;name\u0026#39;: \u0026#39;Test Event\u0026#39;, \u0026#39;description\u0026#39;: \u0026#34;It\u0026#39;s all happening here!\u0026#34;}, {\u0026#39;name\u0026#39;: \u0026#39;Club Presentation - Juniors\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;\u0026#39;}]\u0026gt; values_list() is the same as values(), except it returns tuples:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.values_list() \u0026lt;QuerySet [(1, \u0026#39;Test Event\u0026#39;, datetime.datetime(2019, 8, 25, 22, 42, 15, tzinfo=\u0026lt;UTC\u0026gt;), 1, 1, \u0026#34;It\u0026#39;s all happening here!\u0026#34;), (2, \u0026#39;Club Presentation - Juniors\u0026#39;, datetime.datetime(2019, 8, 1, 12, 0, tzinfo=\u0026lt;UTC\u0026gt;), 4, 2, \u0026#39;\u0026#39;)]\u0026gt; You can also specify which fields to return:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.values_list(\u0026#39;name\u0026#39;) \u0026lt;QuerySet [(\u0026#39;Test Event\u0026#39;,), (\u0026#39;Club Presentation - Juniors\u0026#39;,)]\u0026gt; dates() and datetimes() You use the dates() and datetimes() methods to return time-bounded records from the database (for example, all the events occuring in a particular month). For dates(), these time bounds are year, month, week and day. datetimes() adds hour, minute and second bounds. Some examples:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; Event.objects.dates(\u0026#39;event_date\u0026#39;, \u0026#39;year\u0026#39;) \u0026lt;QuerySet [datetime.date(2019, 1, 1)]\u0026gt; \u0026gt;\u0026gt;\u0026gt; Event.objects.dates(\u0026#39;event_date\u0026#39;, \u0026#39;month\u0026#39;) \u0026lt;QuerySet [datetime.date(2019, 8, 1)]\u0026gt; \u0026gt;\u0026gt;\u0026gt; Event.objects.dates(\u0026#39;event_date\u0026#39;, \u0026#39;week\u0026#39;) \u0026lt;QuerySet [datetime.date(2019, 7, 29), datetime.date(2019, 8, 5), datetime.date(2019, 8, 19)]\u0026gt; \u0026gt;\u0026gt;\u0026gt; Event.objects.dates(\u0026#39;event_date\u0026#39;, \u0026#39;day\u0026#39;) \u0026lt;QuerySet [datetime.date(2019, 8, 1), datetime.date(2019, 8, 10), datetime.date(2019, 8, 11), datetime.date(2019, 8, 25)]\u0026gt; union() The UNION operator is used to combine the result-set of two or more querysets. The querysets can be from the same or from different models. When they querysets are from different models, the fields and their datatypes should match.\n\u0026gt;\u0026gt;\u0026gt; q1 = User.objects.filter(id__gte=5) \u0026gt;\u0026gt;\u0026gt; q1 \u0026lt;QuerySet [\u0026lt;User: Ritesh\u0026gt;, \u0026lt;User: Billy\u0026gt;, \u0026lt;User: Radha\u0026gt;, \u0026lt;User: sohan\u0026gt;, \u0026lt;User: Raghu\u0026gt;, \u0026lt;User: rishab\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; q2 = User.objects.filter(id__lte=9) \u0026gt;\u0026gt;\u0026gt; q2 \u0026lt;QuerySet [\u0026lt;User: yash\u0026gt;, \u0026lt;User: John\u0026gt;, \u0026lt;User: Ricky\u0026gt;, \u0026lt;User: sharukh\u0026gt;, \u0026lt;User: Ritesh\u0026gt;, \u0026lt;User: Billy\u0026gt;, \u0026lt;User: Radha\u0026gt;, \u0026lt;User: sohan\u0026gt;, \u0026lt;User: Raghu\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; q1.union(q2) \u0026lt;QuerySet [\u0026lt;User: yash\u0026gt;, \u0026lt;User: John\u0026gt;, \u0026lt;User: Ricky\u0026gt;, \u0026lt;User: sharukh\u0026gt;, \u0026lt;User: Ritesh\u0026gt;, \u0026lt;User: Billy\u0026gt;, \u0026lt;User: Radha\u0026gt;, \u0026lt;User: sohan\u0026gt;, \u0026lt;User: Raghu\u0026gt;, \u0026lt;User: rishab\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; q2.union(q1) \u0026lt;QuerySet [\u0026lt;User: yash\u0026gt;, \u0026lt;User: John\u0026gt;, \u0026lt;User: Ricky\u0026gt;, \u0026lt;User: sharukh\u0026gt;, \u0026lt;User: Ritesh\u0026gt;, \u0026lt;User: Billy\u0026gt;, \u0026lt;User: Radha\u0026gt;, \u0026lt;User: sohan\u0026gt;, \u0026lt;User: Raghu\u0026gt;, \u0026lt;User: rishab\u0026gt;]\u0026gt; Since Hero and Villain both have the name and gender, we can use values_list to limit the selected fields then do a union.\nHero.objects.all().values_list(  \u0026#34;name\u0026#34;, \u0026#34;gender\u0026#34; ).union( Villain.objects.all().values_list(  \u0026#34;name\u0026#34;, \u0026#34;gender\u0026#34; )) This would give you all Hero and Villain objects with their name and gender.\nselect_related() and prefetch_related() Selecting related information can be a database-intensive operation as each foreign key relationship requires an additional database lookup. For example, each Event object in our database has a foreign key realtionship with the Venue table:\n\u0026gt;\u0026gt;\u0026gt; event1 = Event.objects.get(id=1) \u0026gt;\u0026gt;\u0026gt; event1.venue # Foreign key retrieval causes additional database hit \u0026lt;Venue: South Stadium\u0026gt; For our simple example, this is not a problem, but in large databases with many foreign key relationships, the load on the database can be prohibitive.\nYou use select_related() to improve database performance by retrieving all related data the first time the database is hit:\n\u0026gt;\u0026gt;\u0026gt; event2 = Event.objects.select_related(\u0026#39;venue\u0026#39;).get(id=2) \u0026gt;\u0026gt;\u0026gt; event2.venue # venue has already been retrieved. Database is not hit again. \u0026lt;Venue: East Park\u0026gt; prefetch_related() works the same way as select_related(), except it will work across many-to-many relationships.\nonly() \u0026gt;\u0026gt;\u0026gt; queryset = User.objects.filter(  first_name__startswith=\u0026#39;R\u0026#39; ).only(\u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;) The only difference between only and values is only also fetches the id.\nannotate() Annotations can be simple values, a field reference or an aggregate expression. For example, let’s use Django’s Count aggregate function to annotate our Event model with a total of all users attending each event:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; from django.db.models import Count \u0026gt;\u0026gt;\u0026gt; qry = Event.objects.annotate(total_attendees=Count(\u0026#39;attendees\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; for event in qry: ... print(event.name, event.total_attendees) ... Test Event 0 Gala Day 2 Club Presentation - Juniors 5 Club Presentation - Seniors 3 \u0026gt;\u0026gt;\u0026gt; raw() Executing Raw SQL\nWhile Django’s developers provide the raw() query method for executing raw SQL, you are explicitly discouraged from doing so.\nThe Django ORM is very powerful and in the vast majority of cases where I have seen programmers resort to SQL it has been due to an incomplete knowledge of Django’s ORM on the programmers part, not a deficiency in the ORM.\nIf you find yourself in the situation where a query is so complex you can’t find a way of completing the task with Django’s ORM, it’s likely you need to create a stored procedure or a new view within the database itself.\nMethods That Don’t Return QuerySets:    Method Description     get() Returns a single object. Throws an error if lookup returns multiple objects   create() Shortcut method to create and save an object in one step   get_or_create() Returns a single object. If the object doesn’t exist, it creates one   update_or_create() Updates a single object. If the object doesn’t exist, it creates one   bulk_create() Insert a list of objects in the database   bulk_update() Update given fields in the listed model instances   count() Count the number of objects in the returned QuerySet. Returns an integer   in_bulk() Return a QuerySet containing all objects with the listed IDs   iterator() Evaluate a QuerySet and return an iterator over the results. Can improve performance and memory use for queries that return a large number of objects   latest() Return the latest object in the database table based on the given field(s)   earliest() Return the earliest object in the database table based on the given field(s)   first() Return the first object matched by the QuerySet   last() Return the last object matched by the QuerySet   aggregate() Return a dictionary of aggregate values calculated over the QuerySet   exists() Returns True if the QuerySet contains any results   update() Performs an SQL UPDATE on the specified field(s)   delete() Performs an SQL DELETE that deletes all rows in the QuerySet   as_manager() Return a Manager class instance containing a copy of the QuerySet’s methods   explain() Returns a string of the QuerySet’s execution plan. Used for analysing query performance    Let’s return to the Django interactive shell to dig deeper into some common examples:\nget_or_create() get_or_create() will attempt to retrieve a record matching the search fields. If a record doesn’t exist, it will create one. The return value will be a tuple—the created or retrieved object and a boolean value that will be True if a new record was created:\n\u0026gt;\u0026gt;\u0026gt; from events.models import MyclubUser \u0026gt;\u0026gt;\u0026gt; usr, boolCreated = MyclubUser.objects.get_or_create(first_name=\u0026#39;John\u0026#39;, last_name=\u0026#39;Jones\u0026#39;, email=\u0026#39;johnj@example.com\u0026#39;) \u0026gt;\u0026gt;\u0026gt; usr \u0026lt;MyclubUser: John Jones\u0026gt; \u0026gt;\u0026gt;\u0026gt; boolCreated True If we try and create the object a second time, it will retrieve the new record from the database instead.\n\u0026gt;\u0026gt;\u0026gt; usr, boolCreated = MyclubUser.objects.get_or_create(first_name=\u0026#39;John\u0026#39;, last_name=\u0026#39;Jones\u0026#39;, email=\u0026#39;johnj@example.com\u0026#39;) \u0026gt;\u0026gt;\u0026gt; usr \u0026lt;MyclubUser: John Jones\u0026gt; \u0026gt;\u0026gt;\u0026gt; boolCreated False update_or_create() update_or_create() works similar to get_or_create(), except you pass the search fields and a dictionary named defaults that contains the fields to update. If the object doesn’t exist, it will create a new record in the database:\n\u0026gt;\u0026gt;\u0026gt; usr, boolCreated = MyclubUser.objects.update_or_create(first_name=\u0026#39;Mary\u0026#39;, last_name=\u0026#39;Jones\u0026#39;, defaults={\u0026#39;email\u0026#39;:\u0026#39;maryj@example.com\u0026#39;}) \u0026gt;\u0026gt;\u0026gt; usr \u0026lt;MyclubUser: Mary Jones\u0026gt; \u0026gt;\u0026gt;\u0026gt; boolCreated True If the record does exist, Django will update all fields listed in the defaults dictionary:\n\u0026gt;\u0026gt;\u0026gt; usr, boolCreated = MyclubUser.objects.update_or_create(first_name=\u0026#39;Mary\u0026#39;, last_name=\u0026#39;Jones\u0026#39;, defaults={\u0026#39;email\u0026#39;:\u0026#39;mary_j@example.com\u0026#39;}) \u0026gt;\u0026gt;\u0026gt; usr \u0026lt;MyclubUser: Mary Jones\u0026gt; \u0026gt;\u0026gt;\u0026gt; usr.email \u0026#39;mary_j@example.com\u0026#39; \u0026gt;\u0026gt;\u0026gt; boolCreated False bulk_create() and bulk_update() The bulk_create() saves time by inserting multiple objects into the database at once, most often in a single query. The function has on required parameter—a list of objects:\n\u0026gt;\u0026gt;\u0026gt; usrs = MyclubUser.objects.bulk_create([ ... MyclubUser(first_name=\u0026#39;Jane\u0026#39;, last_name=\u0026#39;Smith\u0026#39;, email=\u0026#39;janes@example.com\u0026#39;), ... MyclubUser(first_name=\u0026#39;Steve\u0026#39;, last_name=\u0026#39;Smith\u0026#39;, email=\u0026#39;steves@example.com\u0026#39;), ... ]) bulk_update() on the other hand takes a list of model objects and updates individual fields on selected model instances. For example, let’s say the first two “Smiths” in the database were entered incorrectly. First, we retrieve all the “Smiths”:\n\u0026gt;\u0026gt;\u0026gt; usrs = MyclubUser.objects.filter(last_name=\u0026#39;Smith\u0026#39;) \u0026gt;\u0026gt;\u0026gt; usrs \u0026lt;QuerySet [\u0026lt;MyclubUser: Joe Smith\u0026gt;, \u0026lt;MyclubUser: Jane Smith\u0026gt;, \u0026lt;MyclubUser: Steve Smith\u0026gt;]\u0026gt; We can then modify the last_name field on the first two instances and use the bulk_update function to save the changes to the database in a single query:\n\u0026gt;\u0026gt;\u0026gt; usrs[0].last_name = \u0026#39;Smythe\u0026#39; \u0026gt;\u0026gt;\u0026gt; usrs[1].last_name = \u0026#39;Smythe\u0026#39; \u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.bulk_update(usrs, [\u0026#39;last_name\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; usrs \u0026lt;QuerySet [\u0026lt;MyclubUser: Joe Smythe\u0026gt;, \u0026lt;MyclubUser: Jane Smythe\u0026gt;, \u0026lt;MyclubUser: Steve Smith\u0026gt;]\u0026gt; count() Count the number of objects in the QuerySet. Can be used to count all the objects in a database table:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.count() 9 Or used to count the number of objects returned by a query:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(last_name=\u0026#39;Smythe\u0026#39;).count() 2 count() is functionally equivalent to using the aggregate() function, for example:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.all().aggregate(Count(\u0026#39;id\u0026#39;)) {\u0026#39;id__count\u0026#39;: 9} But count() has a cleaner syntax and is likely to be faster on larger datasets.\nin_bulk() in_bulk() takes a list of id values and returns a dictionary mapping each id to an instance of the object with that id. If you don’t pass a list to **in_bulk()**, all objects will be returned:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.in_bulk() {1: \u0026lt;MyclubUser: Joe Smythe\u0026gt;, 2: \u0026lt;MyclubUser: Jane Doe\u0026gt;, 3: \u0026lt;MyclubUser: John Jones\u0026gt;} Once retrieved, you can access each object by their key value:\n\u0026gt;\u0026gt;\u0026gt; usrs[3] \u0026lt;MyclubUser: John Jones\u0026gt; \u0026gt;\u0026gt;\u0026gt; usrs[3].first_name \u0026#39;John\u0026#39; Any non-empty list will retrieve all records with the listed ids:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.in_bulk([1]) {1: \u0026lt;MyclubUser: Joe Smythe\u0026gt;} List ids don’t have to be sequential either:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.in_bulk([1, 3, 7]) {1: \u0026lt;MyclubUser: Joe Smythe\u0026gt;, 3: \u0026lt;MyclubUser: John Jones\u0026gt;, 7: \u0026lt;MyclubUser: Mary Jones\u0026gt;} latest() and earliest() Return the latest or the earliest date in the database for the provided field(s):\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; Event.objects.latest(\u0026#39;event_date\u0026#39;) \u0026lt;Event: Test Event\u0026gt; \u0026gt;\u0026gt;\u0026gt; Event.objects.earliest(\u0026#39;event_date\u0026#39;) \u0026lt;Event: Club Presentation - Juniors\u0026gt; first() an last() Return the first or last object in the QuerySet:\n\u0026gt;\u0026gt;\u0026gt; Event.objects.first() \u0026lt;Event: Test Event\u0026gt; \u0026gt;\u0026gt;\u0026gt; Event.objects.last() \u0026lt;Event: Gala Day\u0026gt; aggregate() Returns a dictionary of aggregate values calculated over the QuerySet. For example:\n\u0026gt;\u0026gt;\u0026gt; from django.db.models import Count \u0026gt;\u0026gt;\u0026gt; Event.objects.aggregate(Count(\u0026#39;attendees\u0026#39;)) {\u0026#39;attendees__count\u0026#39;: 7} \u0026gt;\u0026gt;\u0026gt; For a list of all aggregate functions available in Django, see Aggregate Functions later in this chapter.\nexists() Returns True if the returned QuerySet contains any objects, False if the QuerySet is empty. There are two common use cases—to check if an object is contained in another QuerySet:\n\u0026gt;\u0026gt;\u0026gt; from events.models import MyclubUser  # Let\u0026#39;s retrieve John Jones from the database \u0026gt;\u0026gt;\u0026gt; usr = MyclubUser.objects.get(first_name=\u0026#39;John\u0026#39;, last_name=\u0026#39;Jones\u0026#39;)  # And check to make sure he is one of the Joneses \u0026gt;\u0026gt;\u0026gt; joneses = MyclubUser.objects.filter(last_name=\u0026#39;Jones\u0026#39;) \u0026gt;\u0026gt;\u0026gt; joneses.filter(pk=usr.pk).exists() True And to check if a query returns an object:\n\u0026gt;\u0026gt;\u0026gt; joneses.filter(first_name=\u0026#39;Mary\u0026#39;).exists() True \u0026gt;\u0026gt;\u0026gt; joneses.filter(first_name=\u0026#39;Peter\u0026#39;).exists() False Field Lookups: Field lookups have a simple double-underscore syntax:\n\u0026lt;searchfield\u0026gt;__\u0026lt;lookup\u0026gt; For example:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(first_name__exact=\u0026#34;Sally\u0026#34;) \u0026lt;QuerySet [\u0026lt;MyclubUser: Sally Jones\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(first_name__contains=\u0026#34;Sally\u0026#34;) \u0026lt;QuerySet [\u0026lt;MyclubUser: Sally Jones\u0026gt;, \u0026lt;MyclubUser: Sally-Anne Jones\u0026gt;]\u0026gt; Under the hood, Django creates SQL WHERE clauses to construct database queries from the applied lookups. Multiple lookups are allowed and field lookups can also be chained (where logical):\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event  # Get all events in 2019 that occur before September \u0026gt;\u0026gt;\u0026gt; Event.objects.filter(event_date__year=2019, event_date__month__lt=9) \u0026lt;QuerySet [\u0026lt;Event: Test Event\u0026gt;, \u0026lt;Event: Club Presentation - Juniors\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt;  # Get all events occuring on or after the 10th of the month \u0026gt;\u0026gt;\u0026gt; Event.objects.filter(event_date__day__gte=10) \u0026lt;QuerySet [\u0026lt;Event: Test Event\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;]\u0026gt;    Filter Description     exact/iexact Exact match. iexact is case-insensitive version   contains/icontains Field contains search text. icontains is case-insensitive version   in In a given iterable (list, tuple or QuerySet)   gt/gte Greater than/greater than or equal   lt/lte Less than/less than or equal   startswith/istartswith Starts with search string. istartswith is case-insensitive version   endswith/iendswith Ends with search string. iendswithis case-insensitive version   range Range test. Range includes start and finish values   date Casts the value as a date. For datetime field lookups   year Searches an exact year match   iso_year Searches an exact ISO 8601 year match   month Searches an exact month match   day Searches an exact day match   week Searches an exact week match   week_day Searches an exact day of the week match   quarter Searches an exact quarter of the year match. Valid integer range: 1–4   time Casts the value as a time. For datetime field lookups   hour Searches an exact hour match   minute Searches an exact minute match   second Searches an exact second match   isnull Search if field is null. Takes True or False   regex/iregex Regular expression match. iregex is case-insensitive version    Aggregate Functions: Django includes seven aggregate functions:\n Avg. Returns the mean value of the expression Count. Count the number of returned objects Max. Returns the maximum value of the expression Min. Returns the minimum value of the expression StdDev. Returns the population standard deviation of the data in the expression Sum. Returns the sum of all values in the expression Variance. Returns the population variance of the data in the expression  They are translated to the equivalent SQL by Django’s ORM.\nAggregate functions can either be used directly:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; Event.objects.count() 4 Or with the aggregate() function:\n\u0026gt;\u0026gt;\u0026gt; from django.db.models import Count \u0026gt;\u0026gt;\u0026gt; Event.objects.aggregate(Count(\u0026#39;id\u0026#39;)) {\u0026#39;id__count\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; from django.db.models import Avg, Max, Min, Sum, Count \u0026gt;\u0026gt;\u0026gt; User.objects.all().aggregate(Avg(\u0026#39;id\u0026#39;)) {\u0026#39;id__avg\u0026#39;: 7.571428571428571} \u0026gt;\u0026gt;\u0026gt; User.objects.all().aggregate(Max(\u0026#39;id\u0026#39;)) {\u0026#39;id__max\u0026#39;: 15} \u0026gt;\u0026gt;\u0026gt; User.objects.all().aggregate(Min(\u0026#39;id\u0026#39;)) {\u0026#39;id__min\u0026#39;: 1} \u0026gt;\u0026gt;\u0026gt; User.objects.all().aggregate(Sum(\u0026#39;id\u0026#39;)) {\u0026#39;id__sum\u0026#39;: 106} More Complex Queries Query Expressions Query expressions describe a computation or value used as a part of another query. There are six built-in query expressions:\n F()—Represents the value of a model field or annotated column Func()—Base type for database functions like LOWER and SUM Aggregate()—All aggregate functions inherit from Aggregate() Value()—Expression value. Not used directly ExpressionWrapper()—Used to wrap expressions of different types SubQuery()—Add a subquery to a QuerySet  Django supports multiple arithmetic operators with query expressions, including:\n Addition and subtraction Multiplication and division Negation Modulo arithmetic; and The power operator  We have already covered aggregation in this chapter, so let’s have a quick look at the other two commonly used query expressions: F() and Func().\nF() Expressions: The two primary uses for F() expressions is to move computational arithmetic from Python to the database and to reference other fields in the model.\nLet’s start with a simple example, say we want to delay the first event in the event calendar by two weeks. A conventional approach would look like this:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; e = Event.objects.get(id=1) \u0026gt;\u0026gt;\u0026gt; e.event_date += datetime.timedelta(days=14) \u0026gt;\u0026gt;\u0026gt; e.save() In this example, Django retrieves the information from the database into memory, uses Python to perform the computation—in this case, add 14 days to the event date—and then saves the record back to the database.\nFor this example, the overhead for using Python to perform the date arithmetic is not onerous, however for more complex queries there is a definite advantage to moving the computational load to the database.\nNow let’s see how we accomplish the same task with an F() expression:\n\u0026gt;\u0026gt;\u0026gt; from django.db.models import F \u0026gt;\u0026gt;\u0026gt; e = Event.objects.get(id=1) \u0026gt;\u0026gt;\u0026gt; e.event_date = F(\u0026#39;event_date\u0026#39;) + datetime.timedelta(days=14) \u0026gt;\u0026gt;\u0026gt; e.save() In terms of the amount of code necessary to complete the task, we haven’t saved anything, however, by using the F() expression, Django will now create an SQL query that performs the computational logic inside the database, rather than in memory with Python.\nWhile this takes a huge load off the Django application in the case of executing complex computations, there is one drawback—because the calculations take place inside the database, Django is now out of sync with the updated state of the database. We can test this by looking at the Event object instance:\n\u0026gt;\u0026gt;\u0026gt; e.event_date \u0026lt;CombinedExpression: F(event_date) + DurationValue(14 days, 0:00:00)\u0026gt; To retrieve the updated object from the database, we need to use the refresh_from_db() function:\n\u0026gt;\u0026gt;\u0026gt; e.refresh_from_db() \u0026gt;\u0026gt;\u0026gt; e.event_date datetime.datetime(2019, 9, 8, 22, 42, 15, tzinfo=datetime.timezone(datetime.timedelta(0), \u0026#39;+0000\u0026#39;)) The second use for F() expressions—referencing other model fields—is straight forward. For example, you can check for users with the same first and last name:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(first_name=F(\u0026#39;last_name\u0026#39;)) \u0026lt;QuerySet [\u0026lt;MyclubUser: Don Don\u0026gt;]\u0026gt; This simple syntax works with all of Django’s field lookups and aggregate functions.\nFunc() Expressions Func() expressions can be used to represent any function supported by the underlying database (e.g. LOWER, UPPER, LEN, TRIM, CONCAT, etc.). For example:\n\u0026gt;\u0026gt;\u0026gt; from events.models import MyclubUser \u0026gt;\u0026gt;\u0026gt; from django.db.models import F, Func \u0026gt;\u0026gt;\u0026gt; qry = usrs.annotate(f_upper=Func(F(\u0026#39;last_name\u0026#39;), function=\u0026#39;UPPER\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; for usr in qry: ... print(usr.first_name, usr.f_upper) ... Joe SMYTHE Jane DOE John JONES Sally JONES Sally-Anne JONES Sarah JONES Mary JONES Jane SMYTHE Steve SMITH Don DON \u0026gt;\u0026gt;\u0026gt; Notice how we are using F() expressions again to reference another field in the MyclubUser model.\nQ() Objects: Like F() expressions, a Q() object encapsulates an SQL expression inside a Python object. Q() objects are most often used to construct complex database queries by chaining together multiple expressions using AND (\u0026amp;) and OR (|) operators:\n\u0026gt;\u0026gt;\u0026gt; from events.models import MyclubUser \u0026gt;\u0026gt;\u0026gt; from django.db.models import Q \u0026gt;\u0026gt;\u0026gt; Q1 = Q(first_name__startswith=\u0026#39;J\u0026#39;) \u0026gt;\u0026gt;\u0026gt; Q2 = Q(first_name__endswith=\u0026#39;e\u0026#39;) \u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(Q1 \u0026amp; Q2) \u0026lt;QuerySet [\u0026lt;MyclubUser: Joe Smythe\u0026gt;, \u0026lt;MyclubUser: Jane Doe\u0026gt;, \u0026lt;MyclubUser: Jane Smythe\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(Q1 | Q2) \u0026lt;QuerySet [\u0026lt;MyclubUser: Joe Smythe\u0026gt;, \u0026lt;MyclubUser: Jane Doe\u0026gt;, \u0026lt;MyclubUser: John Jones\u0026gt;, \u0026lt;MyclubUser: Sally-Anne Jones\u0026gt;, \u0026lt;MyclubUser: Jane Smythe\u0026gt;, \u0026lt;MyclubUser: Steve Smith\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; You can also perform NOT queries using the negate (~) character:\n\u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(~Q2) \u0026lt;QuerySet [\u0026lt;MyclubUser: John Jones\u0026gt;, \u0026lt;MyclubUser: Sally Jones\u0026gt;, \u0026lt;MyclubUser: Sarah Jones\u0026gt;, \u0026lt;MyclubUser: Mary Jones\u0026gt;, \u0026lt;MyclubUser: Don Don\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; MyclubUser.objects.filter(Q1 \u0026amp; ~Q2) \u0026lt;QuerySet [\u0026lt;MyclubUser: John Jones\u0026gt;]\u0026gt; Model Managers: A Manager is a Django class that provides the interface between database query operations and a Django model. Each Django model is provided with a default Manager named objects. We have been using the default manager every time we query the database, for example:\n\u0026gt;\u0026gt;\u0026gt; newevent = Event.objects.get(name=\u0026#34;Xmas Barbeque\u0026#34;) \u0026gt;\u0026gt;\u0026gt; joneses = MyclubUser.objects.filter(last_name=\u0026#39;Jones\u0026#39;) In each example, objects is the default Manager for the model instance.\nYou can customize the default Manager class, by extending the base Manager class for the model. The two most common use-cases for customizing the default manager are:\n Adding extra manager methods; and Modifying initial QuerySet results.  Adding Extra Manager Methods: Extra manager methods add table-level functionality to models. To add row-level functions, i.e. methods that act on single instances of the model, you use model methods, which we cover in the next section of the chapter.\nExtra manager methods are created by inheriting the Manager base class and adding custom functions to the custom Manager class. For example, let’s create an extra manager method for the Event model that retrieves the total number of events for a particular type of event (e.g. gala day or presentation):\n# myclub_rooteventsmodels.py  from django.db import models from django.contrib.auth.models import User  # ...  1 class EventManager(models.Manager): 2 def event_type_count(self, event_type): 3 return self.filter(name__icontains=event_type).count() 4 5 6 class Event(models.Model): 7 name = models.CharField(\u0026#39;Event Name\u0026#39;, max_length=120) 8 event_date = models.DateTimeField(\u0026#39;Event Date\u0026#39;) 9 venue = models.ForeignKey(Venue, on_delete=models.CASCADE) 10 manager = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL) 11 attendees = models.ManyToManyField(MyclubUser) 12 description = models.TextField(blank=True) 13 objects = EventManager() 14 15 def __str__(self): 16 return self.name  In Line 1, we’ve entered a new class called EventManager that inherits from Django’s models.Manager base class. Lines 2 and 3 is the extra Manager method we’re adding to the model. This new method returns the total number of the specified event type. Note we’re using the icontains field lookup to return all events that have the key phrase in the title. In Line 13 we’re replacing the default manager with our new EventManager class. Note that EventManager inherits from the Manager base class, so all the default manager methods like all() and filter() are automatically included in the custom EventManager() class.  Once it has been created, you can use your new manager method just like any other model menthod:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; Event.objects.event_type_count(\u0026#39;Gala Day\u0026#39;) 1 \u0026gt;\u0026gt;\u0026gt; Event.objects.event_type_count(\u0026#39;Presentation\u0026#39;) 2 Renaming the Default Model Manager While the base manager for each model is named objects by default, you can change the name of the default manager in your class declaration. For example, to change the default manager name for our Event class from objects to events, we just need to change line 13 in the code above from:\n13 objects = EventManager() To:\n13 events = EventManager() Now you can refer to the default manager like so:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; Event.events.all() \u0026lt;QuerySet [\u0026lt;Event: Test Event\u0026gt;, \u0026lt;Event: Club Presentation - Juniors\u0026gt;, \u0026lt;Event: Club Presentation - Seniors\u0026gt;, \u0026lt;Event: Gala Day\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; Overriding Initial Manager QuerySets To modify what is returned by the default manager QuerySet, you override the Manager.get_queryset() method. This is easiest to understand with an example. Let’s say we commonly have to check what venues are listed in our local city. To cut down on the number of queries we have to write, we’re going to create a custom manager for our Venue model (changes in bold):\n# myclub_rooteventsmodels.py  1 from django.db import models 2 from django.contrib.auth.models import User 3 4 5 class VenueManager(models.Manager): 6 def get_queryset(self): 7 return super(VenueManager, self).get_queryset().filter(zip_code=\u0026#39;00000\u0026#39;) 8 9 10 class Venue(models.Model): 11 name = models.CharField(\u0026#39;Venue Name\u0026#39;, max_length=120) 12 address = models.CharField(max_length=300) 13 zip_code = models.CharField(\u0026#39;Zip/Post Code\u0026#39;, max_length=12) 14 phone = models.CharField(\u0026#39;Contact Phone\u0026#39;, max_length=20, blank=True) 15 web = models.URLField(\u0026#39;Web Address\u0026#39;, blank=True) 16 email_address = models.EmailField(\u0026#39;Email Address\u0026#39;,blank=True) 17 18 venues = models.Manager() 19 local_venues = VenueManager() 20 21 def __str__(self): 22 return self.name  # ... Let’s take a look at the changes:\n Lines 5 to 7 is the new VenueManager class. The structure is the same as the EventManager class, except this time we’re overriding the default get_queryset() method and returning a filtered list that only contains local venues. In Line 18 I have renamed the default manager to venues In Line 19 we’re adding the custom model manager (VenueManager)  Note that there is no limit to how many custom managers you can add to a Django model instance. This makes creating custom filters for commonly used queries a breeze. Once you have save the models.py file, you can use the custom methods in your code. For example, the default manager method has been renamed, so you can use the more intuitive venues, instead of objects:\n\u0026gt;\u0026gt;\u0026gt; Venue.venues.all() \u0026lt;QuerySet [\u0026lt;Venue: South Stadium\u0026gt;, \u0026lt;Venue: West Park\u0026gt;, \u0026lt;Venue: North Stadium\u0026gt;, \u0026lt;Venue: East Park\u0026gt;]\u0026gt; And our new custom manager is also easily accessible:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Venue \u0026gt;\u0026gt;\u0026gt; Venue.local_venues.all() \u0026lt;QuerySet [\u0026lt;Venue: West Park\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; Model Methods Django’s Model class comes with many built-in methods. We have already used many of them - save(), delete(), __str__() and others. Where manager methods add table-level functionality to Django’s models, model methods add row-level functions that act on individual instances of the model.\nThere are two common cases where you want to play with model methods:\n When you want to add business logic to the model by adding custom model methods; and When you want to override the default behavior of a built-in model method.  Custom Model Methods As always, it’s far easier to understand how custom model methods work by writing a couple, so let’s go ahead and modify our Event class (changes in bold):\n# myclub_rooteventsmodels.py  # ...  1 class Event(models.Model): 2 name = models.CharField(\u0026#39;Event Name\u0026#39;, max_length=120) 3 event_date = models.DateTimeField(\u0026#39;Event Date\u0026#39;) 4 venue = models.ForeignKey(Venue, on_delete=models.CASCADE) 5 manager = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL) 6 attendees = models.ManyToManyField(MyclubUser) 7 description = models.TextField(blank=True) 8 events = EventManager() 9 10 def event_timing(self, date): 11 if self.event_date \u0026gt; date: 12 return \u0026#34;Event is after this date\u0026#34; 13 elif self.event_date == date: 14 return \u0026#34;Event is on the same day\u0026#34; 15 else: 16 return \u0026#34;Event is befor this date\u0026#34; 17 18 @property 19 def name_slug(self): 20 return self.name.lower().replace(\u0026#39; \u0026#39;,\u0026#39;-\u0026#39;) 21 22 def __str__(self): 23 return self.name Let’s have a look at what’s happening with this new code:\n In Line 10 I have added a new method called event_timing. This is a straight forward method that compares the event date to the date passed to the method and returns a message stating whether the event occurs before, on or after the date. In Line 19 I have added another custom method that returns a slugified event name. The @property decorator on Line 18 allows us to access the method directly, like an attribute. Without the @property, you would have to use a method call (name_slug()).  Let’s test these new methods out in the Django interactive interpreter. Don’t forget to save the model before you start!\nFirst, the name_slug method:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; events = Event.events.all() \u0026gt;\u0026gt;\u0026gt; for event in events: ... print(event.name_slug) ... test-event club-presentation---juniors club-presentation---seniors gala-day This should be easy to follow. Notice how the @property decorator allows us to access the method directly like it was an attribute. I.e. event.name_slug instead of event.name_slug().\nNow to test the event_timing method:\n\u0026gt;\u0026gt;\u0026gt; from datetime import datetime, timezone \u0026gt;\u0026gt;\u0026gt; e = Event.events.get(name=\u0026#34;Gala Day\u0026#34;) \u0026gt;\u0026gt;\u0026gt; e.event_timing(datetime.now(timezone.utc)) \u0026#39;Event is befor this date\u0026#39; \u0026gt;\u0026gt;\u0026gt; Too easy.\nDate and Time in Django\nSomething to note when working with dates in Django. Django uses timezone aware dates, so if you are doing date comparisons like the in any of your code, not just in class methods, you can’t use datetime.now() as Django will throw a TypeError: can't compare offset-naive and offset-aware datetimes. To avoid this error, you must provide timezone information with your dates.\nOverriding Default Model Methods It’s common to want to override built-in model methods like save() and delete() to add business logic to default database behavior.\nTo override a built-in model method you define a new method with the same name. For, example, let’s override the Event model’s default save() method to automatically assign management of the event to a staff member (changes in bold):\n# myclub_rooteventsmodels.py  # ...  1 class Event(models.Model): 2 name = models.CharField(\u0026#39;Event Name\u0026#39;, max_length=120) 3 event_date = models.DateTimeField(\u0026#39;Event Date\u0026#39;) 4 venue = models.ForeignKey(Venue, on_delete=models.CASCADE) 5 manager = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL) 6 attendees = models.ManyToManyField(MyclubUser) 7 description = models.TextField(blank=True) 8 events = EventManager() 9 10 def save(self, *args, **kwargs): 11 self.manager = User.objects.get(username=\u0026#39;abbyb\u0026#39;) 12 super(Event, self).save(*args, **kwargs) # ... The new save() method starts on Line 10. In the overridden save() method, we’re first assigning the staff member with the username “abbyb” to the manager field of the model instance (Line 11), and then we call the default save() method with the super() function to save the model instance to the database (Line 12).\nOnce you save your models.py file, you can test out the overridden model method in the Django interactive shell:\n\u0026gt;\u0026gt;\u0026gt; from events.models import Event \u0026gt;\u0026gt;\u0026gt; from events.models import Venue \u0026gt;\u0026gt;\u0026gt; from datetime import datetime, timezone \u0026gt;\u0026gt;\u0026gt; v = Venue.venues.get(id=1) \u0026gt;\u0026gt;\u0026gt; e = Event.events.create(name=\u0026#39;New Event\u0026#39;, event_date=datetime.now(timezone.utc), venue=v) Once the new record has been created, you can test to see if your override worked by checking the manager field of the Event object:\n\u0026gt;\u0026gt;\u0026gt; e.manager \u0026lt;User: abbyb\u0026gt; \u0026gt;\u0026gt;\u0026gt; Model Inheritance Models are simply Python classes, so inheritance works the same way as normal Python class inheritance. The two most common forms of model inheritance in Django are:\n Multi-table inheritance, where each model has its own database table; and Abstract base classes, where the parent model holds information common to all its child classes, but doesn’t have a database table.  You can also create proxy models that modify the Python-level behavior of a model without modifying the underlying model fields, however, we won’t be covering them here. See the Django documentation for more information on proxy models.\nMulti-table Inheritance Multi-table inheritance is straight forward—the parent class is a normal model and the child inherits the parent by declaring the parent class in the child class declaration. For example:\nclass MyclubUser(models.Model):  first_name = models.CharField(max_length=30)  last_name = models.CharField(max_length=30)  email = models.EmailField(\u0026#39;User Email\u0026#39;)   def __str__(self):  return self.first_name + \u0026#34; \u0026#34; + self.last_name   class Subscriber(MyclubUser):  date_joined = models.DateTimeField() The parent model in the example is the MyclubUser model from our events app. The Subscriber model inherits from MyclubUser and adds an additional field (date_joined). As they are both standard Django model classes, a database table will be created for each model.\nAbstract Base Classes Abstract base classes are handy when you want to put common information into other models without having to create a database table for the base class.\nYou create an abstract base class by adding the abstract = True class Meta option (Line 7 in this example):\n1 class UserBase(models.Model): 2 first_name = models.CharField(max_length=30) 3 last_name = models.CharField(max_length=30) 4 email = models.EmailField(\u0026#39;User Email\u0026#39;) 5 6 class Meta: 7 abstract = True 8 ordering = [\u0026#39;last_name\u0026#39;] 9 10 11 class MyclubUser(UserBase): 12 def __str__(self): 13 return self.first_name + \u0026#34; \u0026#34; + self.last_name 14 15 16 class Subscriber(UserBase): 17 date_joined = models.DateTimeField() Abstract base classes are also useful for declaring class Meta options that are inherited by all child models (Line 8).\nAs the MyclubUser model from our events app now inherits the first name, last name and email fields from UserBase, it only needs to declare the __str__() function to behave the same way as the original MyclubUser model we created earlier.\nThis example is very similar to the example for multi-table inheritance in the previous section, and if you saved and migrated these models, you would get exactly the same result as the above code —Django would create the events_myclubuser and events_subscriber tables in your database, however, because UserBase is and abstract model, it won’t be added to the database as a table.\nReferences:  https://raturi.in/blog/everything-about-django-orm-querysets-field-lookups-model-managers-aggregate-functions-tutorial/ https://www.youtube.com/playlist?list=PLOLrQ9Pn6cazjoDEnwzcdWWf4SNS0QZml  ","permalink":"https://abotyim.github.io/en/posts/django/orm/","summary":"Django ORM — Object Relation Mapper is a powerful and elegant way to interact with the database.","title":"Django ORM"}]